# GRAPH16.HPU
# Опис

Набір графічних підпрограм. Виконання операцій швидше, ніж у процедурах малювання EXOS (за винятком процедури заповнення ), але воно обробляє лише одну 16-кольорову відеосторінку. Колекція підпрограм не використовує канали EXOS, а виділяє сегмент і переносить його на сторінку **3**. Таким чином, програма на Pascal також може безпосередньо отримувати доступ до відеоданих з початкової адреси **C000H**. Розмір екрана становить **40**×**22** символи (**160**×**198** пікселів подвійної ширини), що є найбільшим розміром, який може поміститися на одному сегменті (насправді, це може бути **204** рядки, але це не ціла кількість символів). Колекція рутин підтримує як обробку миші [EnterMice](../../hardware/mouse-entermice.md), так і обробку спрайтів. Машинний код процедур міститься у файлі **GRAPH16.BIN** . Перед використанням колекції підпрограм необхідно звільнити місце для машинного коду за допомогою команди **Alter** (компілятора) наступним чином:

Symbol Table size: **164D** (за замовчуванням)  
Translate Stack: **BA00**  
Compiler Stack: **BA00**  

Методи, які можна використовувати (усі параметри мають тип **integer**, єдиний виняток зазначено):

# Ініціалізація
## GrafInit
Завантажує файл **graph16.bin** та ініціалізує колекцію підпрограм.

## GrafOn
Відкриває відеосторінку розміром **40**×**22** символи та **16**-ма кольорами.

## GrafOff
Закриває відкриту відеосторінку.

## VSyncWait(n)
NICK дозволяє вам чекати в залежності від тактового сигналу. Оскільки він не залежить від тактової частоти процесора, він призупиняє виконання програми на однаковий час на турбо/нетурбо машинах. Якщо код, що виконується між викликами або обробкою переривань EXOS, є повільним, переривання можуть бути втрачені, і в цьому випадку час очікування може дещо залежати від тактової частоти процесора. **N** - 8-бітний параметр, **0** відповідає **256** (найдовше очікування).

## Clear(i)
Очищує відеосторінку кольором **i**.

## Rnd8Init
Ініціалізує власний генератор випадкових чисел. Див. [Rnd8(l,m)](#Функція%20Rnd8(l,m)).

# Налаштування палітри кольорів
## Palette(c0,c1,c2,c3,c4,c5,c6,c7)
Налаштувати перших 8 кольорів палітри. Процедура також оновлює LPT.

## PaletteRL
"Прокрутити" кольори палітри ліворуч. Процедура також оновлює LPT.

## PaletteRR
"Прокрутити" кольори палітри праворуч. Процедура також оновлює LPT.
За допомогою цих двох команд, ви можете легко створювати анімації, які працюють шляхом зміни кольорів палітри.

## Bias(c)
Вибрати BIAS (один з **32** фіксованих наборів для кольорів **8**-**15**). Процедура також оновлює LPT.

## Color(i,c)
Замінити **i**-й колір палітри кольором **c**. Він не оновлює LPT автоматично.

## UpdateLPT
Оновити LPT новими кольорами. Використання процедури має сенс лише після використання [Color](#Color(i,c)) (навіть багаторазового).

----
[Інтерактивна таблиця підбору кольорів](http://ep.lgb.hu/colors.html)


# Базове малювання
## Ink(i)
Вибрати колір для малювання з палітри.

## PlotC(i,x,y)
Намалювати піксель у координатах **x**, **y** кольором **i**.

## Plot(x,y)
Намалювати піксель у координатах **x**, **y** поточним кольором.

## Circle(i,x,y,r)
Намалювати коло радіусом **r** і кольором **i**. Центр кола знаходиться в координатах **x**, **y**.

## Draw(i,x1,y1,x2,y2)
Намалювати лінію між пікселями **x1**, **y1** та **x2**, **y2** кольором **i**.

## Fill(i,x,y)
Заповнити замкнену область екрана кольором **i**, починаючи з позиції **x**, **y**.

## Border(c)
Змінити колір рамки екрану.

## DrawChar(i,x,y,c)
Вивести на екран символ **c** (тип даних **c**:**char**) у вказаних позиціях **x** та **y**, **i** – це колір палітри (**0**..**15**) або **-1**.  

У першому випадку виконується попіксельна операція **Plot()** , яка збільшує одноколірний символ по горизонталі, тоді як пікселі фону залишаються незмінними.

Якщо колір дорівнює **-1**, то використовується байтове малювання, яке є швидшим і передбачає 16-кольоровий (визначений користувачем) набір символів. Цей режим працює коректно, лише якщо **x** парне і весь символ видно (не друкується якщо координати недійсні). В цьому режимі на екран виводиться символ у вигляді блоку 2×9 пікселів.

## Функція GetPixel(x,y)
Запит пікселя у заданій позиції, повернене значення — колір палітри (**0**..**15**) або **-1** для недійсних координат.

# Робота із спрайтами
## SpriteInit(p,s,n,c)
Ініціалізація спрайтів.  
**p**: адреса конвертованих даних спрайту, розміром `N*6*21*4` байтів.  
**s**: адреса буфера для завантаження та конверсії даних спрайтів, розміром `N*6*21` байт *(більше не використовується після SpriteInit)*,  
**n**: кількість фаз анімації,  
**c**: прозорий колір у вхідних даних (**0**..**15**),

> Кожен спрайт має фіксований розмір **11**×**21** пікселів (**6×21=126** байт). В пам'яті для кожного кадру потрібно місце **126**×**4**=**504** байти (кадр + маска + кадр зміщений на піксель + маска зміщена на піксель).

## SpriteNew(b,p)
Ініціалізувати спрайт з початковою адресою 130-байтової області, вказаною в параметрі **b** **(вона має бути парною)**. Той самий параметр використовується у [SpriteDraw](#Функція%20SpriteDraw(b,n,x,y)) та [SpriteClr](#SpriteClr(b)). **p** вказує на дані пікселів, перетворені процедурою [SpriteInit](#SpriteInit(p,s,n,c)), їх розмір становить `N*6*21*4` байтів.  
Кілька спрайтів можуть використовувати одні й ті самі графічні дані, хоча на машині з частотою 4 МГц без мерехтіння можна відобразити лише **2**-**3**.

> Образно кажучи параметр **b** є ідентифікатором спрайту (наскільки я розумію це адреса буферу спрайту (у якому зберігається фон) з адресою поточного кадру анімації).
> 
> Таким чином для завантаження графічних даних спрайтів та створення трьох "унікальних" спрайтів треба виконати наступні дії:
> 
> ```
> p:=#B000-(504*23);   {адреса для зберігання зконвертованих графічних даних спрайтів (23 кадри)}
> b1:=p-130;           {"ідентифікатор" першого спрайту}
> b2:=b1-130;          {"ідентифікатор" другого спрайту}
> b3:=b2-130;          {"ідентифікатор" третього спрайту}
> tin('sprdata.bin',#B000-(126*23));    {завантажуємо файл з графічними даними (23 кадри)}
> SpriteInit(p,#B000-(126*23),23,0);    {конвертуємо дані у кадр з маскою та їх зміщені копії}
> SpriteNew(b1,p);     {ініціалізація першого спрайту}
> SpriteNew(b2,p);     {ініціалізація другого спрайту}
> SpriteNew(b3,p);     {ініціалізація третього спрайту}
> ```
> 
> Кожен спрайт має доступ до усіх завантажених кадрів графічних даних.

## Функція SpriteDraw(b,n,x,y)
Відобразити спрайт у позиціях **x**, **y**. Параметр **b** – це початкова адреса буфера, а **n** – фаза анімації між **0** та раніше заданим значенням **n-1**. У разі недійсних координат нічого не відображатиметься. Додавання **128** до **n** активує перевірку на колізії фону, яка є повільнішою, і в цьому випадку повернене значення є результатом операції **АБО** між перекритими частинами фону, інакше **0**.

## SpriteClr(b)
Видалити раніше відображений спрайт та відновити збережений фон.  
**b**: адреса буфера спрайтів (що зберігає поточний стан та фон), може бути лише парним, розмір **130** байт.

> Щоб вивести або пересунути спрайт на нову позицію використовується функція **SpriteDraw**, а щоб його приховати то задати недійсні координати або використати процедуру **SpriteClr**.


# Робота з мишею та клавіатурою
## ResetMouse(x,y,w)
Встановити координати миші на позиції **x**, **y**. **W** – це позиція прокручування, яка насправді займає лише 8 бітів.

## Функція ReadMouse
Запит на наявність миші, сумісної з [EnterMice](../../hardware/mouse-entermice.md).  
**0**: миша наявна  
**-1**: миша відсутня.  
Оновлює збережений стан для наступних функцій.

## Функція GetMouseX
Поточна позиція вказівника по осі **X**. **X** — це 16-бітове значення зі знаком, що вдвічі перевищує роздільну здатність у 16-кольоровому режимі.

## Функція GetMouseY
Поточна позиція вказівника по осі **Y**.

## Функція GetMouseW
Позиція прокрутки, знакове 8-бітове значення, доповнене до 16-бітового.

## Функція MouseBtn(n)
Поточний стан кнопки миші.  
**-1**: якщо натиснута  
**0**: не натиснута  

**n** =  
**0**: ліва кнопка  
**1**: права кнопка  
**2**: середня кнопка  
**3**:  
**4**: ліва кнопка  
**5**: права кнопка  
**6**: середня кнопка  
**7**:  

Додаючи 4 до n, кнопки можна контролювати "чутливим до країв" способом, і в цьому випадку функція повідомляє лише про подію натискання.  
(Egér gomb (n = 0..3) aktuális állapota, -1 ha le van nyomva, egyébként 0. Az n-hez 4-et hozzáadva "élérzékeny" módon figyelhetők a gombok, ilyenkor a függvény csak a lenyomás eseményét jelzi.)  


## Функція GetKey(n)
Отримати статус клавіші, **n**: позиція матриці `рядок*8+стовпець` (`+128`, якщо джойстик зовнішній). Повертає **0**, якщо клавіша не натиснута, інакше **-1**.

|  _  |   7    |      6       |        5         |        4        |      3       |      2       |       1       |  0   |     |  130 (L)   |  129 (K)   |  128 (J)   |
|:---:|:------:|:------------:|:----------------:|:---------------:|:------------:|:------------:|:-------------:|:----:|:---:|:----------:|:----------:|:----------:|
|  0  | LShift | `Z`<br>(`Y`) |       `X`        |       `V`       |     `C`      |     `B`      | `\`<br>(`><`) | `N`  |     | Ext5 Fire  | Ext3 Fire  | Ext1 Fire  |
|  1  |  Ctrl  |     `A`      |       `S`        |       `F`       |     `D`      |     `G`      |     Lock      | `H`  |     |  Ext5 Up   |  Ext3 Up   |  Ext1 Up   |
|  2  |  Tab   |     `W`      |       `E`        |       `T`       |     `R`      | `Y`<br>(`Z`) |      `Q`      | `U`  |     | Ext5 Down  | Ext3 Down  | Ext1 Down  |
|  3  |  Esc   |     `2`      |       `3`        |       `5`       |     `4`      |     `6`      |      `1`      | `7`  |     | Ext5 Left  | Ext3 Left  | Ext1 Left  |
|  4  |   F1   |      F2      |        F7        |       F5        |      F6      |      F3      |      F8       |  F4  |     | Ext5 Right | Ext3 Right | Ext1 Right |

|  5  |        |    Erase     | `^`<br>( &#96; ) |       `0`       | `-`<br>(`β`) |     `9`      |               | `8`  |     | Ext6 Fire  | Ext4 Fire  | Ext2 Fire  |
|  6  |        | `]`<br>(`#`) |   `:`<br>(`Ä`)   |       `L`       | `;`<br>(`Ö`) |     `K`      |               | `J`  |     |  Ext6 Up   |  Ext4 Up   |  Ext2 Up   |
|  7  |  Alt   |    Enter     |       Left       | Hold<br>(Pause) |      Up      |    Right     |     Down      | Stop |     | Ext6 Down  | Ext4 Down  | Ext2 Down  |
|  8  |  Ins   |    Space     |      RShift      |       `.`       | `/`<br>(`-`) |     `,`      |      Del      | `M`  |     | Ext6 Left  | Ext4 Left  | Ext2 Left  |
|  9  |        |              |   `[`<br>(`+`)   |       `P`       | `@`<br>(`Ü`) |     `O`      |               | `I`  |     | Ext6 Right | Ext4 Right | Ext2 Right |
(**\*** *в дужках позначення для німецької клавіатури*)


# Додаткові функції

## IRQDisable
Вимкнути обробку переривань EXOS (шляхом перезапису адреси **0038h**).

## IRQEnable
Увімкнути обробку переривань EXOS (шляхом перезапису адреси **0038h**).

## Функція Rnd8(i,m)
Простий генератор випадкових чисел, повертає 8-бітове значення після операції **AND** з другим параметром, і результат завжди менший за перше число (наприклад, `Rnd8(5,7)` = значення від **0** до **4**).

